<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Erlang on Code Musings</title>
    <link>https://nayibor.github.io/tags/erlang/index.xml</link>
    <description>Recent content in Erlang on Code Musings</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="https://nayibor.github.io/tags/erlang/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Creating basic tcp server for iso messaging processing .</title>
      <link>https://nayibor.github.io/post/creating-basic-tcp-server-for-iso-messaging-processing-/</link>
      <pubDate>Mon, 12 Dec 2016 07:57:26 +0000</pubDate>
      
      <guid>https://nayibor.github.io/post/creating-basic-tcp-server-for-iso-messaging-processing-/</guid>
      <description>&lt;p&gt;Today we are going to talk about creating a tcp server to &amp;nbsp;parse iso messages using erlang . This tutorial explains the very basic of creating tcp servers in erlang . there are better specialized &amp;nbsp;libraries out there (&lt;a href=&#34;https://github.com/ninenines/ranch&#34;&gt;ranch&lt;/a&gt;) for creating tcp servers and pools of them but this is very basic and we need just a simple tcp server to show how to process incoming iso messages .&amp;nbsp;&lt;br&gt;&lt;/p&gt;&lt;p&gt;We will be using the 1993 iso8583 ascii protocol format .&lt;br&gt;I covered this in a previous post(&lt;a href=&#34;https://nayibor.github.io/post/iso8583-message-structure/&#34;&gt;here&lt;/a&gt;) so you can go there to get a basic summary of iso8583 . knowledge of this protocol and also erlang would help &amp;nbsp;.&lt;/p&gt;&lt;p&gt;to install erlang go &lt;a href=&#34;http://www.erlang.org/downloads&#34;&gt;here&lt;/a&gt;&amp;nbsp;.&amp;nbsp;&lt;/p&gt;&lt;p&gt;the files for the example is contained in this git &amp;nbsp;&lt;a href=&#34;https://github.com/nayibor/iso_process_tut_repo&#34;&gt;&lt;i&gt;repository&lt;/i&gt;&lt;/a&gt; &amp;nbsp;.&amp;nbsp;&lt;/p&gt;&lt;p&gt;Lets hit the road !!&lt;br&gt;&lt;/p&gt;&lt;h2&gt;Creating a basic tcp server in erlang&lt;/h2&gt;&lt;p&gt;lets look at the iso_process.erl file and the portions where the tcp server is created .&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;%% @doc this part is for starting the iso server &lt;br&gt;-spec start_iso_server()-&amp;gt;[pid()] | {error,term()}. &lt;br&gt;start_iso_server()-&amp;gt; ....&lt;br&gt;&lt;/p&gt;&lt;p&gt;%% @doc this part is for listener socket&lt;br&gt;-spec loop_listen(port())-&amp;gt;[port()] | {error,term()} | fun(). &lt;br&gt;loop_listen(Listen_socket)-&amp;gt;....&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;the start_iso_server function and the loop_listen function are responsible for creating the tcp server and erlang processes for handling client connection .&lt;/p&gt;&lt;p&gt;the {ok,Listen} = gen_tcp:listen(...) in &lt;b&gt;start_iso_server&lt;/b&gt; function creates the tcp listener socket and sets up pattern matching so if the listener socket &amp;nbsp;is created successfully the code goes on succesfully else it stops if there is an error(eg.. if port is being used by another program) .&amp;nbsp;&lt;/p&gt;&lt;p&gt;note that because the messages will be coming as strings and also because we want to process only one message at a time we use &lt;b&gt;[list, {packet, 0},{active, once}]&lt;/b&gt; options .strings are represented as lists in erlang so list is in there . the {packet,0} option also tells us to allow messages to flow without breaking it up .&lt;/p&gt;&lt;p&gt;&amp;nbsp;the&lt;b&gt; loop_listen&lt;/b&gt; function&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;%% @doc this part is for listener socket&lt;br&gt;-spec loop_listen(port())-&amp;gt;[port()] | {error,term()} | fun(). &lt;br&gt;loop_listen(Listen_socket)-&amp;gt;...&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&amp;nbsp;is &amp;nbsp;what waits for connections from clients and independently deal with each client connection while the loop_receive is what is responsible for sending/receiving data from clients .&lt;br&gt;&lt;/p&gt;&lt;p&gt;the &lt;b&gt;loop_receive &lt;/b&gt;function&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;%% @doc this part is for the acceptor socket &lt;br&gt;-spec loop_receive(port(),[])-&amp;gt;[pos_integer()] | {error,term()} | fun().        &lt;br&gt;loop_receive(Socket,Isom)-&amp;gt;...&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&amp;nbsp;is the function which receives communicates with clients . i.e. sends and receives data in this case iso messages from clients .&lt;/p&gt;&lt;p&gt;for every iso string(string = header+iso message) sent &amp;nbsp; a check is first done to get the header which contains the size of the iso message messsage itself . the size of the message in the header is then used to calculate &amp;nbsp;how many more bits needs to be streamed to get the whole message in . the iso string is streamed until the whole message is obtained after which it is processed with this function&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;                               Response_message = process_message(Rest),&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;TO run the program do a git clone of the &lt;a href=&#34;https://github.com/nayibor/iso_process_tut_repo&#34;&gt;repo&lt;/a&gt;&amp;nbsp;.&lt;/p&gt;&lt;p&gt;cd to the&amp;nbsp;iso_process_tut_repo folder .&lt;/p&gt;&lt;p&gt;after that log into the erlang shell(erl or werl in windows) and run c(iso_process).&lt;/p&gt;&lt;p&gt;this compiles iso_process.erl module .&lt;/p&gt;&lt;p&gt;&amp;nbsp;then run iso_process.start_iso_server() whch starts the tcp server .&lt;/p&gt;&lt;p&gt;to send messages to server run iso_process:send_message(Message) .&lt;/p&gt;&lt;p&gt;eg .&amp;nbsp;&lt;/p&gt;&lt;p&gt;iso_process:send_message(”&lt;/p&gt;&lt;p&gt;012912007230040102B000001012312313122&lt;/p&gt;&lt;p&gt;0123400001000000011072218000000011612&lt;/p&gt;&lt;p&gt;12081731FABCDE123ABD06414243000termi&lt;/p&gt;&lt;p&gt;d1210Community106A5DFGR”).&lt;/p&gt;&lt;p&gt;you should see a print out of the isomessage showing the various fields .&lt;/p&gt;&lt;p&gt;we will go into how the message is processed and the mti,bitmap,data elements are obtained from the message in the next post as well as how to use jpos to send the messages so we learn a little about both jpos and message processing . neat huh . see u later for that !!!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>